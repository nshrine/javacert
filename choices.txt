DB IMPLEMENTATION

I decided that a simple and robust method of accessing the data file was to
have a single data access object for the server which performs all reading
and writing of the database synchronously (i.e. no data caching, all reading
and writing is directly to and from the file). Therefore this class contains
a single RandomAccessFile instance for accessing the database.

To simplify data integrity any method that moves the file pointer is
synchronized on the Data object's monitor.

I did not make the Data class a singleton to allow for future applications
that may have more than one Data object accessing different data files
simultaneously.

The implementation of the interface for this application does not throw a
DuplicateKeyException as it is valid to have identical records in the database.
This is because there could be more than one room available with the exact
same details. 


LOCKING ALGORITHM

I chose to perform the locking by having a Map object as an instance variable
of the Data class which stores key-value pairs indicating which records are
currently locked. The key is the number of the locked record and the 
associated value is the lock cookie with which the record was locked.

The lock and unlock methods are both synchronized on the Data object's 
monitor such that only one thread can execute either method at a time ensuring
consistency of the state of the Map of locked records when multiple client
threads are calling the Data object's methods. The lock method causes the 
current thread to sleep if the record trying to be locked is already locked.
When unlock is called and a record is unlocked


EXTENDING THE DB INTERFACE 

I extended the DB interface to create an interface appropriate for this 
particular application whereby an additional findExact method was added to
find exact matches to the criteria as specified rather than the superinterface
find method that matches criteria beginning with matching substrings. 

The findExact method also takes as an argument the type of matching of the
criteria to be done, either returning a match if ALL fields match (logical 
AND) or if ANY fields match (logical OR). 

It was necessary to extend the DB interface rather than just adding another 
method to my DB implementation as the transparency of the different operating 
modes (standalone or networked) at the higher levels (GUI code) of the program 
relies on programming to interfaces, thus hiding the underlying implementation.


NETWORK SERVER IMPLEMENTATION

I decided to use RMI for the network client-server communication as it is a
transparent way of calling methods and passing data over the network with a
high-level API without having to deal with network sockets and implementing
a serialisation scheme for transmitting the data. 

For remote data access I simply specified a RemoteBookingDB interface that is
identical to the non-networked BookingDB interface except that it extends the
Remote interface as required by RMI and each method additionally throws a
RemoteException, as also required by the RMI API. I decided that on the 
client side I would wrap the remote instance of the RemoteBookingDB 
implementation in a proxy class that implements the BookingDB interface. In
this way, using the well-known Network proxy paradigm (Chapter 10, Hardcore
Java by Robert Simmons Jr. O'reilly ISBN 0-596-00568-7), it is possible for
the client to transparently work with a BookingDB object with a
factory class providing the appropriate implementation at runtime, either a
BookingData object that accesses the data file within the same JVM or a proxy
to a RemoteBookingData object that accesses the data file across the network. 

Initially RemoteBookingData was a singleton, however when trying to implement
a method for unlocking records when a client has died leaving a record locked
I found that it was useful to have a RemoteBookingData instance per client 
such that I could implement the Unreferenced interface in RemoteBookingData
which would me to handle individual client disconnections on the server side.

I therefore implemented a Remote Server object that clients use to obtain
RemoteBookingData objects.




DOCUMENTATION

Did not Javadoc interface methods.